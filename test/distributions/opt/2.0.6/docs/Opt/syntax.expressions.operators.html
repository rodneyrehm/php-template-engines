<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="pl">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<meta name="robots" content="all" />

	<title>Operators - Open Power Template</title>
	
	<link rel="stylesheet" type="text/css" href="design/generic.css" media="all"  />
	<link rel="stylesheet" type="text/css" href="design/print.css" media="print" />
	<!--[if lte IE 6]><link rel="stylesheet" href="design/ie.css" type="text/css" /><![endif]-->	
	<!--[if IE 7]><link rel="stylesheet" href="design/ie7.css" type="text/css" /><![endif]-->
</head>
<body>

<div id="wrap">
	<div id="header">
		<h1>Open Power Template 2.0</h1>
		<h2>Operators</h2>
		<p class="generated">@ 02.09.2010</p>
		<p class="location"><a href="index.html"><strong>User manual</strong></a> &raquo; <a href="syntax.html">Template syntax</a> &raquo; <a href="syntax.expressions.html">Expressions</a> &raquo; <a href="syntax.expressions.operators.html">Operators</a></p>
	</div>
	
	<div id="content"><dl class="location"><dt><a href="syntax.expressions.html">3.5. Expressions</a><br/>3.5.3. Operators</dt><dd class="prev">3.5.2. Values<br/><a href="syntax.expressions.values.html">&laquo; Previous</a></dd><dd class="next">3.5.4. Functions<br/><a href="syntax.expressions.functions.html">Next &raquo;</a></dd></dl>	<h1>3.5.3. Operators</h1><p>Smaller expressions can create bigger structures thanks to operators. An operator takes the values of the expressions on both left and right side and produces some other result. An example is <code>$a + $b</code> that returns a sum of <code>$a</code> and <code>$b</code>. If we use it in templates, we would print a sum of these variables:</p>

<pre class="xml"><span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;p<span style="color: #000000; font-weight: bold;">&gt;</span></span></span>{$a + $b}<span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;/p<span style="color: #000000; font-weight: bold;">&gt;</span></span></span></pre>

<p>There is also a small set of single argument operators that operate on only one value.</p>

<p>In OPT, some operators have two forms: symbolic and text. They work in the same way. In case of text operators, the compiler can recognize them from the context. If we write <code>eq</code> in a place, where operators are not allowed, it will be treated as a string.</p>

<p>Operator list:</p>

<table>
<thead>
<tr>
  <th>Symbolic</th>
  <th>Text</th>
  <th>Example</th>
  <th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>==</td>
  <td>eq</td>
  <td>$a == $b</td>
  <td align="left">true, if <code>$a</code> is equal <code>$b</code></td>
</tr>
<tr>
  <td>!=</td>
  <td>neq</td>
  <td>$a != $b</td>
  <td align="left">true, if <code>$a</code> is not equal <code>$b</code></td>
</tr>
<tr>
  <td>===</td>
  <td>eqt</td>
  <td>$a === $b</td>
  <td align="left">true, if <code>$a</code> is equal <code>$b</code> and both of them are of the same type</td>
</tr>
<tr>
  <td>!==</td>
  <td>neqt</td>
  <td>$a !== $b</td>
  <td align="left">true, if <code>$a</code> is not equal <code>$b</code> or both of them are of different types</td>
</tr>
<tr>
  <td></td>
  <td>gt</td>
  <td>$a > $b</td>
  <td align="left">true, if <code>$a</code> is greater than <code>$b</code></td>
</tr>
<tr>
  <td></td>
  <td>lt</td>
  <td>$a &lt; $b</td>
  <td align="left">true, if <code>$a</code> is lower than <code>$b</code></td>
</tr>
<tr>
  <td></td>
  <td>gte, ge</td>
  <td>$a >= $b</td>
  <td align="left">true, if <code>$a</code> is greater or equal <code>$b</code></td>
</tr>
<tr>
  <td></td>
  <td>lte, le</td>
  <td>$a &lt;= $b</td>
  <td align="left">true, if <code>$a</code> is lower or equal <code>$b</code></td>
</tr>
<tr>
  <td></td>
  <td>and</td>
  <td>$a and $b</td>
  <td align="left">true, if <code>$a</code> and <code>$b</code> are true</td>
</tr>
<tr>
  <td></td>
  <td>or</td>
  <td>$a or $b</td>
  <td align="left">true, if <code>$a</code> or <code>$b</code> or both of them are true</td>
</tr>
<tr>
  <td></td>
  <td>xor</td>
  <td>$a xor $b</td>
  <td align="left">true, if <code>$a</code> or <code>$b</code> is true, but not both of them at the same time</td>
</tr>
<tr>
  <td>!</td>
  <td>not</td>
  <td>! $a</td>
  <td align="left">true, if <code>$a</code> is false</td>
</tr>
<tr>
  <td>+</td>
  <td>add</td>
  <td>$a + $b</td>
  <td align="left">sum of <code>$a</code> and <code>$b</code></td>
</tr>
<tr>
  <td>-</td>
  <td>sub</td>
  <td>$a - $b</td>
  <td align="left">difference of <code>$a</code> and <code>$b</code></td>
</tr>
<tr>
  <td>*</td>
  <td>mul</td>
  <td>$a * $b</td>
  <td align="left">product of <code>$a</code> and <code>$b</code></td>
</tr>
<tr>
  <td>/</td>
  <td>div</td>
  <td>$a / $b</td>
  <td align="left">quotient of <code>$a</code> and <code>$b</code></td>
</tr>
<tr>
  <td>%</td>
  <td>mod</td>
  <td>$a % $b</td>
  <td align="left">remainder of <code>$a</code> divided by <code>$b</code></td>
</tr>
<tr>
  <td>++</td>
  <td></td>
  <td>$a++, ++$a</td>
  <td align="left">returns <code>$a</code>, and then increases by 1, or firstly increases by 1, and then returns.</td>
</tr>
<tr>
  <td>--</td>
  <td></td>
  <td>$a--, --$a</td>
  <td align="left">returns <code>$a</code>, and then decreases by 1, or firstly decreases by 1, and then returns.</td>
</tr>
<tr>
  <td>~</td>
  <td></td>
  <td>$a ~ $b</td>
  <td align="left">concatenates two values as strings</td>
</tr>
<tr>
  <td>=</td>
  <td>is, are</td>
  <td>@a is $b</td>
  <td align="left">assigns the value of the right-side expression to the variable on the left</td>
</tr>
</tbody>
</table>

<p>A very important thing is the operator precedence. It defines, which operators are processed in the first place, if they are used one by another, like: <code>$a + $b * $c</code>. Multiplication is more important, so the parser will start from <code>$b * $c</code> and then the value of <code>$a</code> will be added to the result. The operator precedence is the same, as in PHP and it is illustrated below:</p>

<ol>
<li><code>++</code>, <code>--</code></li>
<li><code>!</code></li>
<li><code>mul</code>, <code>div</code>, <code>mod</code></li>
<li><code>add</code>, <code>sub</code>, <code>~</code></li>
<li><code>lt</code>, <code>lte</code>, <code>gt</code>, <code>gte</code></li>
<li><code>eq</code>, <code>neq</code>, <code>eqt</code>, <code>neqt</code></li>
<li><code>and</code>, <code>or</code>, <code>xor</code></li>
</ol>

<p>To change the precendence manually, we use brackets: <code>($a + $b) * $c</code>.</p>
<dl class="location location-bottom"><dt>3.5.3. Operators<br/><a href="syntax.expressions.html">3.5. Expressions</a></dt><dd class="prev"><a href="syntax.expressions.values.html">&laquo; Previous</a><br/>3.5.2. Values</dd><dd class="next"><a href="syntax.expressions.functions.html">Next &raquo;</a><br/>3.5.4. Functions</dd></dl>		</div>
	
	<div id="footer">
		<p>Copyright &copy; <a href="http://www.invenzzia.org/">Invenzzia Group 2008-2009</a></p>
		<p>Available under the terms of license: <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation License 1.2</a></p>
		<p>Generated by <strong>TypeFriendly 0.1.4</strong> by <a href="http://www.invenzzia.org/">Invenzzia</a></p>
	</div>
</div>

</body>
</html>